#!/usr/bin/env pytest -vs
"""Tests for check_cve."""

# Standard Python Libraries
import logging
import os
import sys
from unittest.mock import patch

# Third-Party Libraries
import docopt
import pytest

# cisagov Libraries
import check_cve

log_levels = (
    "debug",
    "info",
    "warning",
    "error",
    "critical",
    pytest.param("critical2", marks=pytest.mark.xfail),
)

# define sources of version strings
RELEASE_TAG = os.getenv("RELEASE_TAG")
PROJECT_VERSION = check_cve.__version__
INSECURE_BYTES = br"You don't have permission to access /vpns/"


def test_stdout_version(capsys):
    """Verify that version string sent to stdout agrees with the module version."""
    with pytest.raises(SystemExit):
        with patch.object(sys, "argv", ["exe_name", "--version"]):
            check_cve.check.main()
    captured = capsys.readouterr()
    assert (
        captured.out == f"{PROJECT_VERSION}\n"
    ), "standard output by '--version' should agree with module.__version__"


def test_running_as_module(capsys):
    """Verify that the __main__.py file loads correctly."""
    with pytest.raises(SystemExit):
        with patch.object(sys, "argv", ["bogus", "--version"]):
            # F401 is a "Module imported but unused" warning. This import
            # emulates how this project would be run as a module. The only thing
            # being done by __main__ is importing the main entrypoint of the
            # package and running it, so there is nothing to use from this
            # import. As a result, we can safely ignore this warning.
            # cisagov Libraries
            import check_cve.__main__  # noqa: F401
    captured = capsys.readouterr()
    assert (
        captured.out == f"{PROJECT_VERSION}\n"
    ), "standard output by '--version' should agree with module.__version__"


@pytest.mark.skipif(
    RELEASE_TAG in [None, ""], reason="this is not a release (RELEASE_TAG not set)"
)
def test_release_version():
    """Verify that release tag version agrees with the module version."""
    assert (
        RELEASE_TAG == f"v{PROJECT_VERSION}"
    ), "RELEASE_TAG does not match the project version"


@pytest.mark.parametrize("level", log_levels)
def test_log_levels(level):
    """Validate commandline log-level arguments."""
    with patch.object(
        sys, "argv", ["exe_name", f"--log-level={level}", "bogus.bogus.bogus"]
    ):
        with patch.object(logging.root, "handlers", []):
            assert (
                logging.root.hasHandlers() is False
            ), "root logger should not have handlers yet"
            return_code = check_cve.check.main()
            assert (
                logging.root.hasHandlers() is True
            ), "root logger should now have a handler"
            assert return_code == 3, "main() should return a connection error"


def test_missing_host_arg():
    """Verify the utility handles missing host argument."""
    with pytest.raises(docopt.DocoptExit):
        with patch.object(sys, "argv", ["exe_name"]):
            return_code = check_cve.check.main()
            assert return_code == 254, "main() should return an error"


def test_connection_error():
    """Verify the utility handles missing host argument."""
    with patch.object(sys, "argv", ["exe_name", "bogus.bogus.bogus"]):
        return_code = check_cve.check.main()
        assert return_code == 3, "main() should return an error"


def test_valid_timeout():
    """Test a valid timeout argument."""
    with patch.object(sys, "argv", ["exe_name", "--timeout=5", "github.com"]):
        return_code = check_cve.check.main()
        assert return_code == 0, "main() should return success"


def test_invalid_timeout():
    """Test an invalid timeout argument."""
    with patch.object(sys, "argv", ["exe_name", "--timeout=0", "bogus.bogus.bogus"]):
        return_code = check_cve.check.main()
        assert return_code == 1, "main() should return an error"


def test_valid_retries():
    """Test a valid timeout argument."""
    with patch.object(sys, "argv", ["exe_name", "--retries=0", "github.com"]):
        return_code = check_cve.check.main()
        assert return_code == 0, "main() should return success"


def test_invalid_retries():
    """Test an invalid timeout argument."""
    with patch.object(sys, "argv", ["exe_name", "--retries=-1", "bogus.bogus.bogus"]):
        return_code = check_cve.check.main()
        assert return_code == 1, "main() should return an error"


def test_vuln_host():
    """Verify the utility handles vulnerable host."""
    with patch.object(sys, "argv", ["exe_name", "--log-level=debug", "github.com"]):
        with patch("check_cve.check.urllib3") as mock_lib:
            mock_lib.PoolManager().request().data = INSECURE_BYTES
            mock_lib.PoolManager().request().status = 403
            return_code = check_cve.check.main()
            assert return_code == 2, "main() should return error signaling detection"


def test_non_vuln_host():
    """Verify the utility handles a non-vulnerable host."""
    with patch.object(sys, "argv", ["exe_name", "--log-level=debug", "github.com"]):
        with patch("check_cve.check.urllib3") as mock_lib:
            mock_lib.PoolManager().request().data = b""
            mock_lib.PoolManager().request().status = 403
            return_code = check_cve.check.main()
            assert return_code == 0, "main() should return success"


def test_non_utf8_response():
    """Verify the utility handles responses containing invalid utf-8 data."""
    # Hebrew string saying "forged"
    bogus = "מזויף means bogus"
    bogus_iso_8859_8 = bogus.encode("iso-8859-8")
    with patch.object(sys, "argv", ["exe_name", "--log-level=debug", "github.com"]):
        with patch("check_cve.check.urllib3") as mock_lib:
            mock_lib.PoolManager().request().data = bogus_iso_8859_8
            mock_lib.PoolManager().request().status = 403
            return_code = check_cve.check.main()
            assert return_code == 0, "main() should return success"
