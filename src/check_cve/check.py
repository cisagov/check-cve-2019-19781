#!/usr/bin/env python

"""Check for the existence of CVE-2019-19781 on a host machine.

EXIT STATUS
    This utility exits with one of the following values:
    0   The host does not seem vulnerable
    1   Command was invoked incorrectly
    2   The host appears to be vulnerable
    >2  An error occurred.

For more information about this vulnerability see:
    https://nvd.nist.gov/vuln/detail/CVE-2019-19781

Usage:
  cve-2019-19781 [options] <host>
  cve-2019-19781 (-h | --help)

Options:
  -h --help              Show this message.
  --log-level=LEVEL      If specified, then the log level will be set to
                         the specified value.  Valid values are "debug", "info",
                         "warning", "error", and "critical". [default: info]
  -r --retries=count     Number of times to retry a failed connection attempt before
                         giving up. [default: 2]
  -t --timeout=seconds   Number of seconds to wait during each connection attempt.
                         [default: 10]
"""

# Standard Python Libraries
import logging
import sys

# Third-Party Libraries
import docopt
from schema import And, Schema, SchemaError, Use
import urllib3

from ._version import __version__

INSECURE_CONTENT = r"You don't have permission to access /vpns/"


def is_vulnerable(host, retries=2, timeout=10):
    """Make an http request to a host to see if it is vulnerable."""
    # Suppress insecure request warning
    logging.debug("Disabling insecure request warnings.")
    urllib3.disable_warnings(category=urllib3.exceptions.InsecureRequestWarning)

    # Prevent the relative paths from being normalized away
    logging.debug("Disabling URL normalization.")
    urllib3.util.url.NORMALIZABLE_SCHEMES = ()

    logging.debug(f"Creating connection pool, retries={retries}, timeout={timeout}s")
    pool = urllib3.PoolManager(cert_reqs="CERT_NONE", retries=retries, timeout=timeout)

    # Build URL to solicit a telling response
    url = f"https://{host}/vpn/../vpns/"
    logging.debug(f"Connecting to {url}")
    response = pool.request("GET", url)

    logging.debug(f"Response status: {response.status}")

    decoded_data = response.data.decode("utf-8", errors="ignore")
    logging.debug(f"Data:\n{decoded_data}")

    return INSECURE_CONTENT in decoded_data


def main():
    """Parse arguments, handle logging, and call vulnerability check."""
    args = docopt.docopt(__doc__, version=__version__)

    # Validate and convert arguments as needed
    schema = Schema(
        {
            "--log-level": And(
                str,
                Use(str.lower),
                lambda n: n in ("debug", "info", "warning", "error", "critical"),
                error="Possible values for --log-level are "
                + "debug, info, warning, error, and critical.",
            ),
            "--retries": And(
                Use(int),
                lambda n: n >= 0,
                error="--retries must be an integer greater than or equal to 0.",
            ),
            "--timeout": And(
                Use(int),
                lambda n: n > 0,
                error="--timeout must be an integer greater than 0.",
            ),
            str: object,  # Don't care about other keys, if any
        }
    )

    try:
        args = schema.validate(args)
    except SchemaError as err:
        # Exit because one or more of the arguments were invalid
        print(err, file=sys.stderr)
        return 1

    # Assign validated arguments to variables
    host = args["<host>"]
    log_level = args["--log-level"]
    retries = args["--retries"]
    timeout = args["--timeout"]

    # Set up logging
    logging.basicConfig(
        format="%(asctime)-15s %(levelname)s %(message)s", level=log_level.upper()
    )

    try:
        if is_vulnerable(host, retries, timeout):
            logging.warning(f"{host} appears to be vulnerable.")
            result = 2
        else:
            logging.info(f"{host} does not appear to be vulnerable.")
            result = 0
    except urllib3.exceptions.MaxRetryError as err:
        logging.error(err.reason)
        result = 3

    # Stop logging and clean up
    logging.shutdown()
    return result


if __name__ == "__main__":
    sys.exit(main())
